# Master Project Analysis Reference

## Overview

This is the comprehensive reference for Guild project analysis strategies, technology detection, and complexity profiling. Core sections are extracted for embedding into the setup command.

## Table of Contents

1. [Analysis Intelligence](#analysis-intelligence)
2. [Technology Detection](#technology-detection)
3. [Complexity Profiling](#complexity-profiling)
4. [Agent Generation Strategy](#agent-generation-strategy)
5. [Pattern Recognition](#pattern-recognition)

## Analysis Intelligence

The Guild system uses intelligent project analysis to understand codebases without hardcoded patterns.

<!-- CORE-START -->
## Project Analysis Intelligence

### Pattern-Based Analysis

```yaml
Architectural Patterns:
  - Layered architecture
  - Microservices
  - Component-based
  - Event-driven
  - Domain-driven design
  
Development Flow Patterns:
  - Work organization
  - Lifecycle patterns
  - Quality assurance
  - Deployment strategies
  
Data Flow Patterns:
  - Information movement
  - Transformation logic
  - Processing boundaries
  - State management
  
Integration Patterns:
  - External systems
  - Interface contracts
  - Dependency management
  - API design
  
Scalability Patterns:
  - Growth handling
  - Modularity
  - Extensibility
  - Adaptation points
```

### Complexity Profiling

```yaml
Dimensions:
  Cognitive Complexity:
    - Domain knowledge requirements
    - Context maintenance needs
    - Conceptual interconnections
    - Mental model complexity
    
  Structural Complexity:
    - Pattern interactions
    - Abstraction layers
    - Integration points
    - Component coupling
    
  Change Complexity:
    - Context requirements for changes
    - Ripple effect potential
    - Validation needs
    - Testing complexity
    
  Coordination Complexity:
    - Concern interactions
    - Orchestration needs
    - Parallelization potential
    - Synchronization requirements

Intelligence Allocation:
  High Complexity → Enhanced thinking modes
  Medium Complexity → Standard thinking modes
  Low Complexity → Efficient execution modes
  Mixed Complexity → Adaptive strategies
```
<!-- CORE-END -->

## Technology Detection

### Detection Methodology

The system uses pattern-based detection rather than hardcoded framework names.

<!-- CORE-START -->
## Technology Detection

### Detection Process

```yaml
Analysis Steps:
  1. Project Structure Scan:
     - Directory organization
     - File patterns
     - Naming conventions
     - Module structure
     
  2. Configuration Analysis:
     - package.json, requirements.txt, Cargo.toml
     - Build configurations
     - Environment settings
     - Dependency declarations
     
  3. Source Code Examination:
     - Import patterns
     - Framework usage
     - Library dependencies
     - Architectural styles
     
  4. Workflow Pattern Detection:
     - Development scripts
     - Build processes
     - Test configurations
     - Deployment setups
     
  5. Quality Tool Discovery:
     - Linting configurations
     - Testing frameworks
     - Coverage tools
     - CI/CD pipelines
```

### Pattern Categories

```yaml
Frontend Patterns:
  Component Frameworks:
    - React, Vue, Angular, Svelte
    - Component organization
    - State management patterns
    - Routing structures
    
  State Management:
    - Redux, MobX, Vuex, Pinia
    - Context patterns
    - Store structures
    - Action patterns
    
  Build Tools:
    - Webpack, Vite, Rollup, Parcel
    - Configuration patterns
    - Plugin usage
    - Optimization settings

Backend Patterns:
  API Frameworks:
    - Express, FastAPI, Django, Rails
    - Route organization
    - Middleware patterns
    - Service structure
    
  Database Integration:
    - ORM usage (Prisma, SQLAlchemy, ActiveRecord)
    - Query patterns
    - Migration strategies
    - Connection management
    
  Authentication:
    - JWT, OAuth, Session-based
    - Security patterns
    - Authorization logic
    - User management

CLI Patterns:
  Command Structure:
    - Argument parsing libraries
    - Command organization
    - Subcommand patterns
    - Option handling
    
  User Workflows:
    - Interactive prompts
    - Progress indication
    - Error handling
    - Help systems
    
  Distribution:
    - NPM packages
    - Python packages
    - Binary distribution
    - Installation patterns

Package Patterns:
  API Design:
    - Public interface patterns
    - Export strategies
    - Type definitions
    - Documentation structure
    
  Distribution Strategy:
    - Package managers
    - Version management
    - Dependency handling
    - Publishing workflows
    
  Quality Standards:
    - Testing patterns
    - Documentation requirements
    - API stability
    - Backward compatibility
```
<!-- CORE-END -->

## Complexity Profiling

### Multi-Dimensional Analysis

The system profiles project complexity across multiple dimensions.

**Cognitive Complexity Indicators**:
- Number of domain concepts
- Concept interdependencies
- Knowledge prerequisites
- Mental model requirements

**Structural Complexity Indicators**:
- Component count
- Dependency depth
- Interface complexity
- Coupling metrics

**Change Complexity Indicators**:
- Test requirements
- Impact radius
- Context needs
- Validation complexity

**Coordination Complexity Indicators**:
- Team boundaries
- Service interactions
- Synchronization points
- Communication patterns

## Agent Generation Strategy

### Intelligent Agent Creation

Agents are generated based on detected patterns and complexity profiles.

<!-- CORE-START -->
## Agent Generation Strategy

### Pattern to Agent Mapping

```yaml
Detection → Generation Logic:
  
  CLI Patterns Detected:
    trigger: Command parsing, user interaction patterns
    generate: guild-cli-engineer
    intelligence:
      - Command structure understanding
      - User workflow optimization
      - Distribution expertise
      - Installation patterns
    
  Frontend Patterns Detected:
    trigger: Component frameworks, UI libraries
    generate: guild-frontend-engineer
    intelligence:
      - Component architecture
      - State management
      - UI/UX patterns
      - Frontend testing
    
  Backend Patterns Detected:
    trigger: API frameworks, service patterns
    generate: guild-backend-engineer
    intelligence:
      - API design
      - Service architecture
      - Data persistence
      - Security patterns
    
  Package Patterns Detected:
    trigger: Library structure, distribution setup
    generate: guild-package-engineer
    intelligence:
      - API design
      - Distribution strategy
      - Documentation
      - Versioning
    
  Full-Stack Patterns:
    trigger: Combined frontend + backend
    generate: Multiple specialized engineers
    intelligence: Domain-specific expertise
```

### Intelligence Embedding

```yaml
Project-Specific Knowledge:
  Architectural Understanding:
    - Design patterns used
    - Component relationships
    - Data flow patterns
    - Integration points
    
  Technology Context:
    - Framework versions
    - Library ecosystem
    - Tool configurations
    - Development workflow
    
  Quality Standards:
    - Testing approaches
    - Code style
    - Documentation standards
    - Performance requirements
    
  Domain Knowledge:
    - Business logic patterns
    - User workflows
    - Data models
    - External integrations
```
<!-- CORE-END -->

## Pattern Recognition

### Analysis Prompts

The system uses sophisticated prompts for project analysis.

<!-- CORE-START -->
## Analysis Prompts

### Project Analysis Prompt Template

```
Perform comprehensive project analysis using all available tools.

Focus Areas:
1. Technology-Agnostic Pattern Recognition
   - Identify architectural patterns beyond specific tools
   - Understand domain patterns and business logic
   - Recognize quality and development patterns
   
2. Complexity Assessment
   - Evaluate cognitive load requirements
   - Assess structural complexity
   - Determine change impact patterns
   - Identify coordination needs
   
3. Technology Stack Detection
   - Discover frameworks and libraries
   - Identify development tools
   - Understand build and deployment
   - Recognize quality tools
   
4. Workflow Understanding
   - Development processes
   - Testing strategies
   - Deployment patterns
   - Collaboration workflows

Output: Comprehensive project profile for agent generation
```

### Agent Generation Prompt Template

```
Based on project analysis, generate specialized agents with:

1. Embedded Project Intelligence
   - Architectural understanding
   - Technology expertise
   - Domain knowledge
   - Quality standards
   
2. Optimal Configuration
   - Thinking mode assignment
   - Context optimization settings
   - Parallel execution capability
   - Handoff protocols
   
3. Specialization Focus
   - Core competencies
   - Technology coupling
   - Workflow integration
   - Quality responsibilities

Output: Complete agent definitions with embedded intelligence
```
<!-- CORE-END -->

## Best Practices

### Analysis Guidelines

1. **Pattern Over Names**: Focus on patterns, not framework names
2. **Holistic View**: Consider all aspects of the project
3. **Context Awareness**: Understand domain and business logic
4. **Quality Focus**: Identify testing and validation patterns
5. **Evolution Ready**: Design for project growth

### Detection Strategies

1. **Start Broad**: Begin with high-level patterns
2. **Drill Down**: Progressively analyze details
3. **Cross-Reference**: Validate findings across sources
4. **Avoid Assumptions**: Let evidence guide conclusions
5. **Document Findings**: Record analysis results

## Integration Points

<!-- CORE-START -->
## Integration Points

### Setup Command Embedding
This module provides:
- Analysis strategies
- Detection patterns
- Complexity profiling
- Generation logic

### Agent Creation
Drives agent generation:
- Pattern detection
- Intelligence embedding
- Configuration optimization
- Specialization assignment

### Workflow Adaptation
Influences workflow:
- Complexity-based strategies
- Resource allocation
- Parallelization decisions
- Quality gate configuration

## Key Invariants

1. **Pattern-Based**: Use patterns, not hardcoded framework names
2. **Intelligence Embedding**: All agents get project knowledge
3. **Complexity-Driven**: Match resources to complexity
4. **Technology-Agnostic**: Work with any technology stack
5. **Adaptive Generation**: Create agents based on actual needs
<!-- CORE-END -->

## Troubleshooting

### Common Issues

1. **Pattern Misidentification**: Verify with multiple sources
2. **Complexity Underestimation**: Review all dimensions
3. **Missing Technologies**: Check configuration files
4. **Agent Mismatch**: Validate pattern detection
5. **Intelligence Gaps**: Ensure comprehensive analysis

### Debug Strategies

- Enable verbose analysis logging
- Inspect intermediate results
- Validate pattern detection
- Review complexity scores
- Check agent generation

## Advanced Topics

### Custom Pattern Definition

Creating new pattern categories for specialized domains.

**Process**:
1. Identify unique characteristics
2. Define detection criteria
3. Map to agent types
4. Embed intelligence
5. Test generation

### Complexity Calibration

Adjusting complexity thresholds for specific environments.

**Calibration Factors**:
- Team expertise level
- Project maturity
- Performance requirements
- Quality standards
- Resource constraints

### Evolution Tracking

Monitoring project evolution over time.

**Tracking Metrics**:
- Pattern emergence
- Complexity growth
- Technology adoption
- Quality improvements
- Architecture changes