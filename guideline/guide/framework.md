# Guild System Framework

## Core Philosophy

**Structure enables intelligence. Intelligence optimizes structure.**

The Guild system balances systematic methods with adaptive intelligence:

- **Systematic Foundation**: Provides reliability and comprehensive coverage
- **Intelligent Optimization**: Enables excellence and creative solutions  
- **Unified Integration**: Combines both for superior outcomes
- **Continuous Evolution**: Improves systems based on insights

## Decision Authority

**Clear boundaries resolve conflicts:**

- **Structure Governs**: Safety standards, quality gates, coverage requirements
- **Intelligence Governs**: Implementation approaches, problem-solving, optimization
- **User Decides**: Scope, priorities, trade-offs, satisfaction

**Existing-First, Parallel-Smart**: Discover existing specialists first, then optimize with parallel coordination

## Core Principles

**Adaptive Intelligence**: Trust native intelligence within coordination boundaries. Use systematic understanding for multi-agent work while preserving creative autonomy.

**Parallel-First Execution**: Default to simultaneous execution for efficiency. Sequential requires explicit dependency justification.

**Systematic Decomposition**: Break tasks into parallelizable units. Components run parallel unless dependencies require coordination.

**Intelligent Dependencies**: Minimize blocking dependencies. Focus on essential coordination points only.

**Strategic Adaptation**: Adapt existing specialists first, create only when discovery exhausted. Batch adaptation when parallel work provides clear advantages.

## Task Decomposition

**Coordination Sequence:**
1. Confirm understanding and multi-agent strategy
2. Discover existing specialists in `.claude/agents/guild/`
3. Assess adaptation potential and compatibility scores
4. Plan specialist adaptation and selective creation strategy
5. Minimize blocking dependencies through intelligent coordination
6. Execute autonomously within framework
7. Verify completion and iterate

**Existing-First Analysis:**
- What existing specialists are available in `.claude/agents/guild/`?
- How can existing specialists be adapted for current requirements?
- What compatibility scores do existing specialists achieve?
- What new specialists are needed only after exhausting existing options?
- How do adapted and new specialists integrate efficiently?

**Specialist Selection Guidelines:**
- ✅ Existing specialists with 60+ compatibility for adaptation
- ✅ Multiple existing specialists covering different domains efficiently
- ✅ Adaptation potential that preserves specialist expertise while extending capabilities
- ✅ Coordination benefits that exceed adaptation complexity
- ⚠️ Creating new specialists without exhausting existing adaptation options
- ⚠️ Compatibility scores below 60% without documented justification for new creation

## Dependency Coordination

**Dependency Assessment:**
For each potential dependency:
- Is this truly blocking or can interfaces enable parallel work?
- Can contracts/abstractions enable parallel development?
- Can mocks, stubs, or integration strategies work?
- Would splitting create beneficial parallel opportunities?

**Coordination Required:**
- Shared data structures affecting consumers
- Authentication affecting protected features  
- API contracts affecting consumer implementation
- Build dependencies affecting same artifacts
- File operations affecting exact same files

**Parallel Opportunities:**
- Independent files with coordination checkpoints
- Different layers (frontend/backend/database)
- Separate features with integration coordination
- Documentation alongside implementation
- Testing alongside implementation
- Research alongside initial implementation
- UI and API through contracts/interfaces
- Different modules with integration checkpoints

**Coordination Patterns:**
- **Interface-First**: Define contracts early, enable parallel development
- **Mock-Driven**: Create mocks for dependencies, develop in parallel  
- **Event-Driven**: Use events/messages for loose coupling
- **Layer Contracts**: API contracts enable UI/backend parallel work
- **Integration Points**: Define verification with adaptive approaches

## Specialist Creation

**Specialist Intelligence Principles:**
- **Adaptive Reasoning**: Specialists adapt approaches based on context
- **Intelligent Coordination**: Natural collaboration with defined interfaces  
- **Creative Problem-Solving**: Novel solutions within scope, escalate coordination needs
- **Context-Aware Decisions**: Autonomous decisions within approved boundaries
- **Intelligent Verification**: Quality assessment and gap detection

**Creation Assessment Criteria:**
1. Multiple expertise domains benefit from focused intelligence
2. Independent work provides clear parallel execution benefits
3. Deep investigation benefits from dedicated intelligence
4. Domain expertise accelerates work beyond coordination overhead
5. Multiple specialists provide net efficiency gains

**Assessment Questions:**
- What specialized intelligence provides beneficial focus?
- Where can parallel reasoning justify coordination complexity?
- Which aspects benefit from problem-solving vs integrated execution?
- How can specialists coordinate through intelligent interfaces?
- What creative approaches might emerge from distributed intelligence?

**Coordination Patterns:**

**Strategic Expertise Distribution:** Complementary intelligence areas, knowledge sharing, adaptive expertise, efficient coordination

**Coordinated Parallel Reasoning:** Independent analysis streams, consensus building, creative synthesis, adaptive solutions

**Adaptive Intelligence Scaling:** Core capability assessment, create as complexity emerges, specialist recommendations, adaptive evolution

**Creation Approaches:**

**Dynamic Specialists:** Task tool with "general-purpose", embed intelligence expectations, creative problem-solving, intelligent coordination

**Persistent Agents:** /agents command for recurring patterns, domain expertise with reasoning, reusable frameworks, adaptive evolution

**Decision Framework:** Based on complexity needs, frequency patterns, persistent vs dynamic value, distributed vs centralized benefits

## Quality Standards

**Simplification Principles:**
- Trust native intelligence - avoid over-specification
- Use simple templates without detailed implementations  
- Essential patterns only - remove verbose examples
- Concise principles over exhaustive documentation
- Clean intelligence patterns

**Documentation Standards:**
- Keep principles concise, trust intelligence for implementation
- Use simple markers like `[track-metrics]` over verbose examples
- Eliminate redundant sections, consolidate concepts
- Focus on essential patterns, not comprehensive specifications
- Maintain lightweight cross-references

## Tool Requirements

**Tool/Specialist Descriptions (3-4 sentences minimum):**
1. Primary purpose and functionality
2. When to use vs avoid
3. Important limitations and caveats
4. Expected outcomes and side effects

**Parameter Documentation:**
- Clear purpose and format
- Valid values and constraints
- Required vs optional designation
- Examples of valid inputs

**Error Handling:**
- Structured error responses
- Actionable error messages
- Recovery strategies
- Fallback approaches

## Execution Flow

**Phase 1: Understanding**
- Use chain of thought for comprehensive understanding
- Apply systematic interpretation and coordination strategy
- Resolve scope and coordination requirements
- Execute with autonomous intelligence within boundaries
- Report understanding and approach

**Phase 2: Decomposition**
1. Assess parallel opportunities (primary optimization)
2. Decompose into efficient units (balanced components)
3. Analyze coordination requirements (minimize dependencies)
4. Plan strategic specialist launches (balance benefits/efficiency)
5. Design coordination interfaces (integration points)

**Decomposition Examples:**
- **Feature Addition**: UI + API + Database + Tests + Docs
- **Bug Fix**: Research + Reproduce + Fix + Test + Document
- **Refactor**: Analysis + Plan + Implementation + Testing + Migration
- **Research**: Multiple domain experts with coordination

**Phase 3: Execution**
- Launch parallel specialists when benefits exceed overhead
- Batch specialist creation for efficiency gains
- Sequential execution when coordination complexity exceeds benefits
- Provide comprehensive descriptions (3-4 sentences)
- Include error handling with coordination escalation
- Build in gap detection and continuous verification
- Monitor and coordinate execution with integration
- Implement coordination interfaces before launch

**Phase 4: Verification**
Success evaluation:
1. User satisfaction (ultimate authority)
2. Technical verification (functional requirements)
3. Integration validation (system coherence)
4. Quality compliance (maintainability standards)

Verification approach:
- Functional verification through intelligent analysis
- Integration verification through adaptive coordination
- Quality verification through intelligent assessment
- Cross-domain gap detection
- Adaptive remediation coordination

**No Auto-Persist:**
- Analysis in-memory only, presented in conversation
- No automatic file creation unless user requests
- Clean execution without unwanted filesystem artifacts

**Phase 5: Iteration**
If gaps found or user not satisfied:
1. Intelligent gap analysis across domains
2. Strategic remediation planning with coordination
3. Efficient fix implementation (optimal parallel/sequential)
4. Adaptive re-verification across affected domains
5. User satisfaction confirmation with recommendations

## Success Criteria

**Understanding Confirmed:**
- User approves understanding and coordination approach
- All clarifications addressed
- Scope clearly defined with coordination boundaries
- Execution approach confirmed with parallel optimization

**Technical Verification Complete:**

**Functional Success:** All requested functionality implemented, user requirements satisfied, core workflows completing end-to-end

**Integration Success:** Components integrated and communicating, data flows working across boundaries, integration points tested

**Quality Success:** Code follows project patterns, maintainable and well-structured, appropriate error handling

**Final Success Authority:**
- User confirms satisfaction across all domains
- All technical verification streams completed
- User satisfaction maintained with technical compliance
- Explicit approval with quality standards met

**Conflict Resolution:**
- Technical passes but user unsatisfied → iterate until user satisfied
- User satisfied but technical issues → resolve technical while maintaining satisfaction
- User satisfaction has final authority, technical integrity must be maintained

## Best Practices

**Follow Anthropic best practices from guideline/guide/recommendations.md**

**Verification Standards:**
- Confirm understanding and coordination before multi-agent execution
- Implement verification methodology across domains
- Launch verification specialists when efficiency benefits exceed overhead
- Coordinate verification results with integration
- Resolve conflicts using adaptive success evaluation
- Check for gaps systematically across domains
- Iterate until user satisfied with technical completion
- Get explicit user confirmation as final validation

**Verification Coordination:**
- Create verification specialists when domains provide efficiency gains
- Coordinate remediation across parallel streams
- Maintain user satisfaction while ensuring technical integrity
- Use cross-specialist gap detection as beneficial practice

**Implementation Principles:**
- Use XML tags for structure with adaptive application
- Provide clear, explicit instructions with context adaptation
- Apply chain of thought for reasoning with creative problem-solving
- Ground in actual project files with intelligent analysis
- Allow uncertainty expression with coordination escalation
- Include examples for complex tasks with adaptive guidance
- Verify work iteratively with intelligent assessment

## Balance Principles

- **Avoid rigid compliance** → Use adaptive guidance balancing structure with intelligence
- **Templates as guidance** → Apply patterns intelligently based on context
- **Balance coordination with simplicity** → Interfaces enhance rather than constrain execution
- **Optimize complexity for value** → Guidance serves understanding, not procedural compliance
- **Structure coordination, preserve intelligence** → Enable multi-agent work while preserving autonomy

## Intelligent Decision Framework

**Decision Transparency Pattern:**
When making specialist creation decisions, provide brief reasoning:

**Simple Task Pattern:**
```
"Using direct execution - single domain task, coordination overhead exceeds benefits"
"Implementing directly - straightforward fix without coordination complexity"
```

**Complex Task Pattern:**
```  
"Creating specialists - multi-domain work benefits from parallel execution"
"Using specialist network - coordination efficiency justifies overhead"
```

**Conditional Pattern:**
```
"Assessing complexity... determined [decision] based on [criteria]"
"Evaluated scope: [analysis] → [execution approach] most efficient"
```

**Decision Criteria Communication:**
- Scope complexity assessment
- Parallel execution benefits vs coordination overhead
- Existing specialist compatibility scores
- Domain expertise acceleration potential

## Decision Transparency Examples

**Decision Process Demonstration:**

**Complex Multi-Domain Task:**
User: "Add authentication to my app"

**Intelligence Assessment:**
- Scope: Multi-domain (API + UI + Database + Testing + Documentation)
- Complexity: High coordination benefits justify specialist approach
- Decision: Create specialist network for parallel execution

**Existing-First Analysis:**

Discovery of available specialists in `.claude/agents/guild/`:
- typescript-specialist (development-tools): API implementation capability
- nodejs-specialist (development-tools): Server-side authentication patterns
- testing-specialist (quality-assurance): Test development and validation
- file-operations-specialist (template-configuration): Schema and config management
- readme-specialist (documentation-knowledge): Documentation creation

**Adaptation Assessment:**
- typescript-specialist → Extend for JWT API endpoints (80% compatibility)
- nodejs-specialist → Adapt for authentication middleware (85% compatibility)
- testing-specialist → Extend for auth testing patterns (90% compatibility)
- file-operations-specialist → Adapt for user schema files (70% compatibility)
- readme-specialist → Extend for auth documentation (75% compatibility)

**Parallel Adaptation Execution:**

Simultaneous specialist adaptation:
- **typescript-specialist** (adapted): JWT API endpoints with authentication contracts
- **nodejs-specialist** (adapted): Authentication middleware and session management
- **testing-specialist** (extended): Authentication test suite with mocking strategies
- **file-operations-specialist** (adapted): User schema and configuration file management
- **readme-specialist** (extended): Setup, usage, and security documentation

New creation only when needed:
- **Security review**: Create security-specialist for architecture review (no existing match <60%)

Coordination framework:
- **Shared Contracts**: Authentication API contracts defined by adapted typescript-specialist
- **Mock Strategy**: Adapted testing-specialist provides authentication mocks for development
- **Integration Points**: Verification checkpoints coordinated by existing specialists
- **Iterative Security**: New security-specialist provides specialized review feedback