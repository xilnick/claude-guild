# Guild System Framework

## Core Philosophy

**Structure enables intelligence. Intelligence optimizes structure.**

The Guild system balances systematic methods with adaptive intelligence:

- **Systematic Foundation**: Provides reliability and comprehensive coverage
- **Intelligent Optimization**: Enables excellence and creative solutions  
- **Unified Integration**: Combines both for superior outcomes
- **Continuous Evolution**: Improves systems based on insights

## Compliance Architecture

**Systematic Excellence Framework**: Guild system operates with consistent excellence across six critical dimensions with template-first intelligence patterns and mandatory abstraction standards:

**FOUNDATIONAL REQUIREMENT - Intelligence Abstraction Compliance:**
All Guild intelligence must maintain complete abstraction from specific implementations:
- **Absolute Code Prohibition**: Never include code samples, syntax examples, or executable snippets
- **Complete Technology Independence**: Never reference specific languages, frameworks, libraries, or tools
- **Mandatory Template Usage**: All guidance must use abstract `[placeholder]` patterns exclusively  
- **Native Intelligence Trust**: Complete reliance on autonomous intelligence for contextual implementations
- **Creative Solution Preservation**: Enable intelligent adaptation without constraining implementation choices

**FOUNDATIONAL REQUIREMENT - Analysis-First Intelligence:**
All Guild operations must prioritize dynamic analysis over prescriptive declarations:
- **Always Analyze Instead of Declaring**: Use intelligence to examine actual conditions rather than making predetermined assumptions
- **Context-Driven Decisions**: Base all choices on real-time analysis of project characteristics and requirements
- **Dynamic Discovery**: Discover optimal approaches through analysis rather than following predetermined patterns
- **Assumption Challenge**: Question preset conclusions and verify through intelligent examination
- **Adaptive Implementation**: Allow analysis results to guide implementation choices rather than constraining with fixed declarations
- **Evidence-Based Execution**: Ground all decisions in analyzed evidence rather than assumed or declared requirements

### 1. Tool Parallelization Mandate

**Template-First Parallelization Standards:**
- **Intelligence-Driven Tool Batching**: Execute `[tool-operations]` simultaneously using `[parallelization-intelligence]` and `[batch-coordination]` patterns
- **Abstract Capability Assessment**: Evaluate `[tool-capabilities]` through `[assessment-templates]` for optimal parallel execution
- **Template-Based Resource Management**: Balance `[concurrent-operations]` using `[resource-intelligence]` and `[optimization-frameworks]`

**Systematic Tool Parallelization Framework:**
- **Mandatory Parallel Execution**: Default to simultaneous tool operations using `[parallel-templates]` unless proven sequential dependencies exist
- **Tool Capability Profiling**: Comprehensive assessment through `[profiling-intelligence]` of available tools and performance characteristics
- **Parallel Operation Design**: Strategic coordination using `[coordination-templates]` of multiple tool executions for maximum efficiency
- **Resource Constraint Management**: Intelligent balancing through `[balancing-frameworks]` of system resources during parallel tool operations

**Parallelization Excellence:**
- **Multi-Tool Coordination**: Simultaneous execution of complementary tools using `[multi-tool-templates]` for comprehensive analysis
- **Capability-Aware Batching**: Strategic grouping through `[batching-intelligence]` based on tool performance profiles and resource requirements
- **Parallel Dependency Challenge**: Automatic verification using `[dependency-templates]` of assumed tool sequencing requirements
- **Performance Optimization**: Real-time monitoring through `[optimization-intelligence]` and adjustment of parallel tool execution patterns

**Tool Parallelization Enforcement:**
- **Sequential Execution Prevention**: Automatic blocking of unnecessary sequential tool operations through `[prevention-mechanisms]`
- **Parallel Default Protocol**: Mandatory parallel execution unless explicit dependencies proven through `[dependency-verification]`
- **Tool Efficiency Tracking**: Continuous monitoring using `[tracking-templates]` of parallelization effectiveness and optimization opportunities
- **Resource Utilization Monitoring**: System-wide tracking through `[monitoring-intelligence]` of parallel tool performance and capacity optimization

### 2. Agent-Mandatory Architecture

**Template-First Implementation Standards:**
- **Intelligence-Driven Assignment**: Use `[task-type]` evaluation through `[assignment-protocol]` patterns
- **Abstract Agent Creation**: Create `[domain-specialist]` using `[capability-framework]` assessment
- **Template-Based Execution**: Route all `[operation-categories]` through `[specialist-coordination]` patterns

**Systematic Delegation Protocol:**
- **Decision Architecture**: Every task flows through specialist assignment evaluation
- **Agent Creation**: Standardized specialist development with capability assessment  
- **Execution Framework**: Operations require appropriate specialist delegation

**Implementation Principles:**
- **Task Assessment**: Evaluate requirements for specialist assignment using `[assessment-patterns]`
- **Direct Prevention**: Block inappropriate direct execution through `[blocking-mechanisms]`
- **Assignment Protocol**: Route tasks to appropriate specialists via `[routing-intelligence]`
- **Monitoring**: Track compliance with delegation standards through `[monitoring-frameworks]`

**Agent Development Protocol:**
- **Discovery**: Scan existing specialists using `[discovery-intelligence]` before creation
- **Compatibility**: Assess alignment using `[systematic-metrics]` and `[scoring-frameworks]`
- **Creation Justification**: Document necessity through `[justification-patterns]` for new specialists
- **Integration Planning**: Define coordination patterns using `[integration-intelligence]` before activation

### 3. Parallel-First Execution Engine

**Template-First Parallel Standards:**
- **Intelligence-Driven Decomposition**: Break `[complex-tasks]` into `[parallel-components]` using `[decomposition-intelligence]`
- **Abstract Dependency Analysis**: Challenge `[sequential-assumptions]` through `[dependency-intelligence]` patterns
- **Template-Based Coordination**: Orchestrate `[parallel-streams]` using `[coordination-templates]` and `[synchronization-patterns]`

**Systematic Decomposition Framework:**
- **Task Analysis**: Break tasks into atomic parallelizable units using `[analysis-patterns]`
- **Dependency Discovery**: Identify true vs. assumed dependencies with `[challenge-protocols]`
- **Parallel Optimization**: Default to simultaneous execution through `[parallel-intelligence]` unless proven dependencies exist
- **Synchronization Design**: Plan integration points using `[integration-templates]` before parallel execution begins

**Execution Orchestration:**
- **Decomposition**: Systematic requirement for task breakdown using `[decomposition-frameworks]`
- **Dependency Challenge**: Automatic verification through `[assumption-intelligence]` of sequential assumptions
- **Parallel Default**: Simultaneous execution via `[parallel-coordination]` unless proven dependencies exist
- **Operation Batching**: Coordinate related operations through `[batching-intelligence]` for efficiency
- **Monitoring**: Track parallel execution effectiveness using `[monitoring-templates]`

**Coordination Excellence:**
- **Batch Identification**: Recognize groupable operations across domains
- **Resource Management**: Prevent conflicts while maximizing parallelization
- **Progress Integration**: Monitor parallel streams with systematic checkpoints
- **Performance Enhancement**: Continuous efficiency monitoring with automatic improvements

### 4. Research Protocol Integration

**Template-First Research Standards:**
- **Intelligence-Driven Discovery**: Execute `[research-protocols]` through `[discovery-intelligence]` before implementation
- **Abstract Validation Patterns**: Verify `[current-standards]` using `[modernization-intelligence]` frameworks  
- **Template-Based Analysis**: Map `[impact-areas]` through `[analysis-templates]` and `[relationship-patterns]`

**Comprehensive Discovery Framework:**
- **Pre-Execution Research**: Required comprehensive discovery using `[research-templates]` before implementation
- **Modernization Validation**: Verification through `[validation-intelligence]` of current standards and best practices
- **Impact Analysis**: Mapping of all affected project areas using `[impact-templates]`
- **Dependency Discovery**: Complete relationship mapping through `[dependency-intelligence]` before implementation

**Research Excellence:**
- **Discovery Gates**: Project structure and technology analysis using `[analysis-frameworks]` requirements
- **Modernization Verification**: Current version and best practice validation through `[verification-templates]`
- **Impact Mapping**: Complete affected area identification using `[mapping-intelligence]`
- **Parallel Research**: Simultaneous discovery across domains through `[parallel-research-templates]`
- **Completeness Audit**: Systematic verification through `[audit-intelligence]` of research thoroughness

**Discovery Coordination:**
- **Simultaneous Exploration**: Parallel project structure, technology, and dependency analysis using `[exploration-templates]`
- **Pattern Recognition**: Identification through `[pattern-intelligence]` of architectural patterns and conventions
- **Gap Identification**: Areas requiring modernization through `[gap-analysis-templates]` or improvement
- **Integration Assessment**: Impact mapping across project boundaries using `[integration-intelligence]`

### 5. Agent Recursion Prevention

**Template-First Anti-Recursion Standards:**
- **Intelligence-Driven Hierarchy Management**: Maintain `[flat-agent-architecture]` through `[hierarchy-intelligence]` and `[prevention-patterns]`
- **Abstract Recursion Detection**: Prevent `[subagent-recursion]` using `[detection-templates]` and `[blocking-mechanisms]`
- **Template-Based Coordination Control**: Enforce `[single-level-delegation]` through `[coordination-intelligence]` and `[execution-boundaries]`

**Mandatory Anti-Recursion Architecture:**
- **Flat Agent Hierarchy**: Only main system creates and invokes agents using `[primary-delegation-patterns]`
- **Subagent Recursion Prevention**: Absolute prohibition against agents creating additional agents through `[prevention-mechanisms]`
- **Single-Level Delegation**: All agent invocation flows through primary system using `[delegation-intelligence]`
- **Recursion Detection**: Runtime monitoring through `[detection-templates]` for recursion attempts and automatic blocking

**Anti-Recursion Implementation:**
- **Primary System Authority**: Only main Guild system has agent creation capabilities using `[authority-templates]`
- **Subagent Constraint Enforcement**: Agents blocked from invoking other agents through `[constraint-intelligence]`
- **Execution Boundary Definition**: Clear separation using `[boundary-templates]` between agent capabilities and system functions
- **Resource Protection**: Prevention of infinite recursion through `[protection-patterns]` and resource exhaustion

**Recursion Prevention Enforcement:**
- **Agent Creation Blocking**: Automatic prevention using `[blocking-templates]` of subagent creation attempts
- **Invocation Filtering**: Runtime detection through `[filtering-intelligence]` and prevention of agent-to-agent calls
- **Compliance Monitoring**: Continuous tracking using `[monitoring-templates]` for recursion attempt detection
- **Violation Response**: Immediate termination through `[response-mechanisms]` of recursion attempts with logging

**Anti-Recursion Excellence:**
- **Hierarchy Integrity**: Maintain flat agent structure using `[integrity-templates]` with single-level delegation
- **Performance Protection**: Prevent resource exhaustion through `[protection-intelligence]` from recursive operations
- **Coordination Clarity**: Clear agent boundaries using `[clarity-templates]` with primary system orchestration
- **Compliance Assurance**: Systematic prevention through `[assurance-intelligence]` of architectural violations

### 6. Operation Batching Optimization

**Template-First Batching Standards:**
- **Intelligence-Driven Classification**: Group `[operation-types]` using `[classification-intelligence]` and `[resource-patterns]`
- **Abstract Performance Patterns**: Minimize context switching through `[batching-templates]` and `[optimization-intelligence]`
- **Template-Based Coordination**: Balance `[parallel-execution]` with `[resource-constraints]` using `[coordination-frameworks]`

**Systematic Batching Framework:**
- **Operation Classification**: Group operations by type, resource usage using `[classification-templates]` and interdependencies
- **Performance Enhancement**: Minimize context switching through `[optimization-intelligence]` strategic operation grouping
- **Resource Balance**: Coordinate parallel execution through `[balancing-templates]` with system resource constraints
- **Efficiency Tracking**: Real-time performance monitoring using `[tracking-intelligence]` with systematic optimization

**Operation Batching Implementation:**
- **Operation Type Classification**: Systematic categorization using `[classification-templates]` of operations by resource requirements and execution patterns
- **Dependency Analysis**: Comprehensive evaluation using `[analysis-intelligence]` of operation interdependencies and sequencing requirements
- **Batch Size Optimization**: Dynamic calculation through `[optimization-templates]` of optimal operation group sizes for resource efficiency
- **Context Switch Minimization**: Strategic grouping using `[grouping-intelligence]` to reduce system overhead and improve execution efficiency

**Batching Excellence:**
- **Intelligent Batch Coordination**: Coordinate related operations using `[coordination-templates]` for optimal resource utilization and execution efficiency
- **Strategic Operation Grouping**: Smart operation batching through `[grouping-intelligence]` based on resource requirements and execution dependencies
- **Batch Performance Monitoring**: Real-time efficiency tracking using `[monitoring-templates]` of batch execution effectiveness and optimization metrics
- **Resource-Aware Batch Management**: Automatic load balancing through `[management-intelligence]` for optimal batch sizes and system capacity
- **Batching Pattern Recognition**: Systematic approaches using `[pattern-templates]` for identifying optimal operation combinations and batch structures

**Efficiency Framework:**
- **Batch Performance Metrics**: Track batch execution time, resource utilization efficiency using `[metrics-intelligence]` and success rates with operation-specific profiling
- **Operation Batching Profiling**: Monitor batch execution patterns through `[profiling-templates]` and operation grouping optimization opportunities
- **Batching Intelligence**: Automatic recommendations using `[optimization-templates]` for improved batch composition patterns based on operation characteristics
- **Dynamic Batch Balancing**: Adaptive batch sizing adjustment through `[balancing-intelligence]` based on system capacity and operation complexity
- **Batch Success Monitoring**: Track efficiency improvements using `[success-templates]` and performance gains with operation batching utilization metrics

## Dimensional Integration Framework

**Cross-Dimensional Coordination**: All six compliance dimensions operate as an integrated system with systematic interdependencies and mutual reinforcement patterns.

### Dimension Interaction Matrix

**Primary Integration Patterns:**

**Tool Parallelization ↔ Operation Batching**
- Tool parallelization enables operation batching optimization through `[concurrent-execution-patterns]`
- Operation batching coordinates parallel tool execution through `[batch-coordination-templates]`
- Shared resource management through `[resource-balancing-intelligence]` across both dimensions

**Agent-Mandatory ↔ Agent Recursion Prevention**
- Agent-mandatory architecture enforces flat hierarchy through `[delegation-authority-patterns]`
- Recursion prevention blocks unauthorized agent creation through `[constraint-enforcement-templates]`
- Single-level delegation ensures compliance with both dimensions through `[hierarchy-intelligence]`

**Parallel-First ↔ Tool Parallelization**
- Parallel-first execution optimizes tool coordination through `[parallel-coordination-templates]`
- Tool parallelization enables comprehensive parallel execution through `[multi-tool-patterns]`
- Dependency challenge protocols apply to both task and tool sequencing through `[dependency-intelligence]`

**Research Protocol ↔ All Dimensions**
- Research gates validate compliance requirements across all dimensions through `[compliance-validation-templates]`
- Discovery protocols inform optimal dimension implementation through `[analysis-intelligence]`
- Impact analysis ensures dimensional coordination through `[integration-assessment-patterns]`

### Systematic Integration Protocols

**Compliance Coordination:**
- All dimensions must operate simultaneously through `[multi-dimensional-compliance-templates]`
- No dimension can override another's requirements through `[precedence-intelligence]`
- Integration failures trigger systematic correction through `[correction-protocols]`

**Performance Optimization:**
- Cross-dimensional efficiency monitoring through `[integration-metrics-intelligence]`
- Resource sharing optimization across dimensional boundaries through `[resource-coordination-templates]`
- Performance bottleneck identification spanning multiple dimensions through `[bottleneck-analysis-patterns]`

**Excellence Assurance:**
- Multi-dimensional verification through `[integrated-verification-templates]`
- Quality standards maintained across all dimensional interactions through `[quality-coordination-intelligence]`
- User satisfaction confirmation spanning complete dimensional integration through `[satisfaction-validation-patterns]`

## Mandatory Intelligence Standards

**CRITICAL REQUIREMENT**: All Guild intelligence must adhere to mandatory abstraction and template-first principles.

**MANDATORY INTELLIGENCE REQUIREMENTS:**
1. **NEVER Include Code Samples**: Absolutely forbidden to include specific code implementations, syntax examples, or executable code snippets
2. **NEVER Reference Specific Technologies**: Prohibited from mentioning specific languages, frameworks, libraries, or tools by name
3. **ALWAYS Use Templates**: Mandatory use of abstract placeholder patterns for all implementation guidance
4. **ALWAYS Parallelize Tools**: Mandatory requirement for simultaneous tool execution unless proven sequential dependencies exist
5. **NEVER Allow Agent Recursion**: Absolute prohibition against subagents creating or invoking additional agents
6. **RELY ON Native Intelligence**: Complete trust in autonomous intelligence to determine appropriate implementations
7. **ENABLE Creative Solutions**: Provide structural guidance without constraining intelligent implementation choices
8. **ALWAYS Analyze Instead of Declaring**: Mandatory requirement to examine actual conditions through intelligence rather than making predetermined assumptions or declarations

**ENFORCEMENT PROTOCOL:**
- **Code Sample Detection**: Automatic blocking of any code implementation examples
- **Technology Specificity Audit**: Systematic removal of technology-specific references  
- **Template Compliance**: Mandatory abstraction validation for all guidance patterns
- **Tool Parallelization Enforcement**: Systematic prevention of sequential tool execution without proven dependencies
- **Agent Recursion Prevention**: Automatic blocking of subagent creation or invocation attempts
- **Intelligence Trust Verification**: Confirmation that native intelligence drives all implementation decisions
- **Analysis-First Enforcement**: Systematic verification that decisions are based on actual analysis rather than predetermined declarations

## Template Principles

**Templates as Intelligence Enablers**: All templates provide structural guidance while trusting native intelligence for implementation details.

**Core Template Requirements:**
- **Never Include Code Samples**: Templates must not contain specific code implementations or technology examples
- **Never Specify Technologies**: Avoid references to specific languages, frameworks, or tools
- **Always Use Placeholders**: Abstract all implementation details with `[category]` patterns
- **Always Enable Tool Parallelization**: Templates must support simultaneous tool execution patterns by default
- **Never Allow Agent Recursion**: Templates must prevent subagents from creating or invoking additional agents
- **Trust Native Intelligence**: Rely on autonomous intelligence to determine appropriate implementations
- **Enable Creativity**: Provide structure that guides without constraining intelligent solutions

**Template Characteristics:**
- **Minimal Specificity**: Use placeholders like `[task-description]` rather than detailed implementations
- **Structural Guidance**: Show the pattern, not the complete solution
- **Intelligence Enablers**: Provide enough structure to guide, not enough to constrain
- **Parallelization Support**: Enable simultaneous tool execution patterns and parallel operation coordination
- **Anti-Recursion Architecture**: Enforce flat agent hierarchy with single-level delegation patterns
- **Adaptable Framework**: Templates work across different contexts and use cases without modification
- **Compliance Integration**: Embed enforcement mechanisms into template execution patterns including tool parallelization and agent recursion prevention
- **Technology Agnostic**: Complete independence from specific technologies, languages, or frameworks
- **Implementation Freedom**: Enable native intelligence to choose optimal implementation approaches

**Abstract Placeholder Standards:**
- **Always Abstract**: Use `[domain]`, `[task-type]`, `[approach]` instead of specific implementations
- **No Technology References**: Use `[framework]`, `[language]`, `[tool]` instead of specific technologies
- **Keep Consistent Standards**: Always use `thinking_mode: ultrathink` for maximum reasoning capability
- **Generic References**: Use `@config:[pattern-id]` instead of specific config codes
- **Placeholder Patterns**: Use `[category]-specialist` instead of specific specialist names
- **Directory Templates**: Use `[project-path]` instead of actual paths

**Standardized Elements (Never Abstract):**
- **Thinking Mode**: Always `thinking_mode: ultrathink` for maximum intelligence
- **Model Configuration**: Always `model: inherit` for consistency
- **Core Framework Terms**: Keep "systematic", "excellence", "coordination" as standard vocabulary
- **Compliance References**: Maintain framework terminology for consistency

**Intelligence-First Approach:**
- **Native Intelligence Priority**: Templates assume autonomous intelligence will make optimal implementation choices
- **Contextual Adaptation**: Intelligence adapts templates to specific project contexts and requirements
- **Creative Solutions**: Enable intelligence to find innovative approaches within structural boundaries
- **Dynamic Implementation**: Allow intelligence to determine best practices based on current analysis

**Template vs Over-Specification:**
- ✅ **Template**: `<specialist_prompt>Handle [domain] requirements using [approach]</specialist_prompt>`
- ❌ **Over-Specified**: Detailed specialist prompts with specific implementations or code samples
- ✅ **Abstract**: `Analyze [project-structure] using [discovery-patterns]`
- ❌ **Concrete**: `Run npm install && analyze package.json dependencies`
- ✅ **Consistent**: `thinking_mode: ultrathink` (standard for all agents)
- ❌ **Variable**: `thinking_mode: [reasoning-level]` (should not be abstracted)

**Enforcement Standards:**
- **Code Sample Prevention**: Templates must never include executable code or implementation examples
- **Technology Neutrality**: Templates must work across all technology stacks without modification
- **Tool Parallelization Mandate**: Templates must default to simultaneous tool execution patterns unless dependencies proven
- **Agent Recursion Prevention**: Templates must enforce flat agent hierarchy with mandatory single-level delegation
- **Intelligence Trust**: Templates must rely on native intelligence for all implementation decisions
- **Abstraction Validation**: All templates undergo abstraction compliance verification

**MANDATORY COMPLIANCE ENFORCEMENT:**
- **Absolute Code Prohibition**: Zero tolerance for code samples, syntax examples, or executable snippets
- **Complete Technology Abstraction**: Mandatory removal of all technology-specific references
- **Template-First Requirement**: All guidance must use abstract placeholder patterns exclusively
- **Tool Parallelization Supremacy**: Mandatory simultaneous tool execution unless proven sequential dependencies exist
- **Agent Recursion Prohibition**: Zero tolerance for subagent creation or invocation by agents
- **Native Intelligence Supremacy**: Full reliance on autonomous intelligence for implementation decisions
- **Creativity Preservation**: Protection of intelligent solution space through structural boundaries only

**Violation Prevention Protocol:**
- **Pre-deployment Scanning**: Automatic detection and removal of code samples before template activation
- **Technology Reference Audit**: Systematic identification and abstraction of specific technology mentions
- **Sequential Tool Execution Detection**: Monitoring and prevention of unnecessary sequential tool operations
- **Agent Recursion Detection**: Runtime monitoring and immediate blocking of subagent creation or invocation attempts
- **Intelligence Bypass Detection**: Monitoring for over-specification that constrains native intelligence
- **Template Purity Verification**: Confirmation that templates maintain complete abstraction standards including tool parallelization and anti-recursion enforcement

**Philosophy**: Templates trust intelligence to fill in the details appropriately for each context while enforcing compliance automatically. Templates provide structural guidance without constraining intelligent solutions, enabling creative and contextually appropriate implementations through native intelligence with mandatory tool parallelization for optimal performance.

## Success Criteria

- **Understanding Confirmed**: User approves scope and approach
- **Technical Complete**: All verification streams pass
- **User Satisfied**: Explicit approval received
- **Quality Maintained**: Standards met throughout
- **Excellence Achieved**: High compliance across all framework dimensions verified

## Sub-Agent Integration

**Claude Code Sub-Agent Standards:**
Based on Anthropic's official sub-agent architecture, Guild specialists follow these enhanced patterns:

### Sub-Agent Architecture

**Core Sub-Agent Principles:**
- **Specialized Expertise**: Each specialist has focused domain knowledge and specific tool configurations
- **Context Management**: Independent context windows for specialized work without polluting main conversation
- **Flexible Configuration**: Project-level and user-level agents with customizable tool permissions
- **Automatic Delegation**: Claude Code proactively selects appropriate specialists based on task analysis
- **Anti-Recursion Constraint**: Subagents must never create or invoke additional agents - flat hierarchy enforced

**Sub-Agent Creation Standards:**
- **Focused Responsibility**: Single-purpose specialists with clear boundaries
- **Detailed Prompts**: Comprehensive system prompts for consistent performance
- **Tool Restrictions**: Limited tool access aligned with specialist purpose
- **Version Control**: Project-level agents managed in repository
- **Recursion Prevention**: Built-in constraints preventing agent creation or invocation capabilities

**Sub-Agent Invocation Methods:**
- **Proactive Selection**: Framework automatically delegates based on task description and specialist configuration
- **Explicit Request**: Direct invocation when specific expertise needed
- **Chain Coordination**: Multi-specialist workflows for complex tasks through primary system only
- **Primary System Authority**: Only main Guild system can create, invoke, or coordinate agents

### Sub-Agent Best Practices

**Configuration Excellence:**
- Write detailed, specific system prompts for consistent behavior
- Use "PROACTIVELY" in descriptions to encourage automatic delegation
- Limit tool permissions to necessary functions only
- Version control project-level sub-agents in `.claude/agents/` directory
- Embed anti-recursion constraints in all agent prompts and configurations

**Performance Optimization:**
- Preserve main conversation context through specialized delegation
- Accept minimal latency for focused expertise
- Chain specialists for complex multi-step workflows
- Dynamic selection based on task context and requirements

**Framework Integration:**
- All Guild specialists follow sub-agent architecture standards
- Enhanced with systematic coordination patterns
- Integrated with compliance monitoring and excellence tracking
- Optimized for parallel execution and batching operations
- Enforced flat hierarchy with mandatory anti-recursion constraints

### Claude Code Integration

**Standard Sub-Agent Categories:**
1. **Code Reviewer**: Quality assurance and best practices validation
2. **Debugger**: Error identification and resolution
3. **Data Scientist**: Analysis and modeling tasks

**Guild-Enhanced Categories:**
- **Domain Specialists**: Technology-specific expertise (frontend, backend, etc.)
- **Process Specialists**: Workflow coordination (testing, deployment, etc.)
- **Quality Specialists**: Verification and compliance (security, performance, etc.)
- **Coordination Specialists**: Integration and orchestration management

## Best Practices

- Use XML tags for structure (per `recommendations.md`)
- Apply chain of thought for complex analysis
- Ground work in actual project files
- Allow uncertainty expression
- Verify iteratively
- Get explicit user confirmation
- **Enforce excellence through systematic processes, not manual oversight**
- **Create sub-agents with focused expertise and clear boundaries**
- **Use proactive delegation to maintain context efficiency**
- **Version control project-level specialists for consistency**

**Templates as guidance, not constraints. Structure enables intelligence to excel. Excellence ensures systematic success.**

