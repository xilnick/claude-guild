# Guild System Framework

## Core Philosophy

**Structure enables intelligence. Intelligence optimizes structure.**

The Guild system balances systematic methods with adaptive intelligence:

- **Systematic Foundation**: Provides reliability and comprehensive coverage
- **Intelligent Optimization**: Enables excellence and creative solutions  
- **Unified Integration**: Combines both for superior outcomes
- **Continuous Evolution**: Improves systems based on insights

## Compliance Architecture

**Systematic Excellence Framework**: Guild system operates with consistent excellence across four critical dimensions with template-first intelligence patterns and mandatory abstraction standards:

**FOUNDATIONAL REQUIREMENT - Intelligence Abstraction Compliance:**
All Guild intelligence must maintain complete abstraction from specific implementations:
- **Absolute Code Prohibition**: Never include code samples, syntax examples, or executable snippets
- **Complete Technology Independence**: Never reference specific languages, frameworks, libraries, or tools
- **Mandatory Template Usage**: All guidance must use abstract `[placeholder]` patterns exclusively  
- **Native Intelligence Trust**: Complete reliance on autonomous intelligence for contextual implementations
- **Creative Solution Preservation**: Enable intelligent adaptation without constraining implementation choices

### 1. Agent-Mandatory Architecture

**Template-First Implementation Standards:**
- **Intelligence-Driven Assignment**: Use `[task-type]` evaluation through `[assignment-protocol]` patterns
- **Abstract Agent Creation**: Create `[domain-specialist]` using `[capability-framework]` assessment
- **Template-Based Execution**: Route all `[operation-categories]` through `[specialist-coordination]` patterns

**Systematic Delegation Protocol:**
- **Decision Architecture**: Every task flows through specialist assignment evaluation
- **Agent Creation**: Standardized specialist development with capability assessment  
- **Execution Framework**: Operations require appropriate specialist delegation

**Implementation Principles:**
- **Task Assessment**: Evaluate requirements for specialist assignment using `[assessment-patterns]`
- **Direct Prevention**: Block inappropriate direct execution through `[blocking-mechanisms]`
- **Assignment Protocol**: Route tasks to appropriate specialists via `[routing-intelligence]`
- **Monitoring**: Track compliance with delegation standards through `[monitoring-frameworks]`

**Agent Development Protocol:**
- **Discovery**: Scan existing specialists using `[discovery-intelligence]` before creation
- **Compatibility**: Assess alignment using `[systematic-metrics]` and `[scoring-frameworks]`
- **Creation Justification**: Document necessity through `[justification-patterns]` for new specialists
- **Integration Planning**: Define coordination patterns using `[integration-intelligence]` before activation

### 2. Parallel-First Execution Engine

**Template-First Parallel Standards:**
- **Intelligence-Driven Decomposition**: Break `[complex-tasks]` into `[parallel-components]` using `[decomposition-intelligence]`
- **Abstract Dependency Analysis**: Challenge `[sequential-assumptions]` through `[dependency-intelligence]` patterns
- **Template-Based Coordination**: Orchestrate `[parallel-streams]` using `[coordination-templates]` and `[synchronization-patterns]`

**Systematic Decomposition Framework:**
- **Task Analysis**: Break tasks into atomic parallelizable units using `[analysis-patterns]`
- **Dependency Discovery**: Identify true vs. assumed dependencies with `[challenge-protocols]`
- **Parallel Optimization**: Default to simultaneous execution through `[parallel-intelligence]` unless proven dependencies exist
- **Synchronization Design**: Plan integration points using `[integration-templates]` before parallel execution begins

**Execution Orchestration:**
- **Decomposition**: Systematic requirement for task breakdown using `[decomposition-frameworks]`
- **Dependency Challenge**: Automatic verification through `[assumption-intelligence]` of sequential assumptions
- **Parallel Default**: Simultaneous execution via `[parallel-coordination]` unless proven dependencies exist
- **Operation Batching**: Coordinate related operations through `[batching-intelligence]` for efficiency
- **Monitoring**: Track parallel execution effectiveness using `[monitoring-templates]`

**Coordination Excellence:**
- **Batch Identification**: Recognize groupable operations across domains
- **Resource Management**: Prevent conflicts while maximizing parallelization
- **Progress Integration**: Monitor parallel streams with systematic checkpoints
- **Performance Enhancement**: Continuous efficiency monitoring with automatic improvements

### 3. Research Protocol Integration

**Template-First Research Standards:**
- **Intelligence-Driven Discovery**: Execute `[research-protocols]` through `[discovery-intelligence]` before implementation
- **Abstract Validation Patterns**: Verify `[current-standards]` using `[modernization-intelligence]` frameworks  
- **Template-Based Analysis**: Map `[impact-areas]` through `[analysis-templates]` and `[relationship-patterns]`

**Comprehensive Discovery Framework:**
- **Pre-Execution Research**: Required comprehensive discovery using `[research-templates]` before implementation
- **Modernization Validation**: Verification through `[validation-intelligence]` of current standards and best practices
- **Impact Analysis**: Mapping of all affected project areas using `[impact-templates]`
- **Dependency Discovery**: Complete relationship mapping through `[dependency-intelligence]` before implementation

**Research Excellence:**
- **Discovery Gates**: Project structure and technology analysis using `[analysis-frameworks]` requirements
- **Modernization Verification**: Current version and best practice validation through `[verification-templates]`
- **Impact Mapping**: Complete affected area identification using `[mapping-intelligence]`
- **Parallel Research**: Simultaneous discovery across domains through `[parallel-research-templates]`
- **Completeness Audit**: Systematic verification through `[audit-intelligence]` of research thoroughness

**Discovery Coordination:**
- **Simultaneous Exploration**: Parallel project structure, technology, and dependency analysis using `[exploration-templates]`
- **Pattern Recognition**: Identification through `[pattern-intelligence]` of architectural patterns and conventions
- **Gap Identification**: Areas requiring modernization through `[gap-analysis-templates]` or improvement
- **Integration Assessment**: Impact mapping across project boundaries using `[integration-intelligence]`

### 4. Operation Batching Optimization

**Template-First Batching Standards:**
- **Intelligence-Driven Classification**: Group `[operation-types]` using `[classification-intelligence]` and `[resource-patterns]`
- **Abstract Performance Patterns**: Minimize context switching through `[batching-templates]` and `[optimization-intelligence]`
- **Template-Based Coordination**: Balance `[parallel-execution]` with `[resource-constraints]` using `[coordination-frameworks]`

**Systematic Batching Framework:**
- **Operation Classification**: Group operations by type, resource usage using `[classification-templates]` and interdependencies
- **Performance Enhancement**: Minimize context switching through `[optimization-intelligence]` strategic operation grouping
- **Resource Balance**: Coordinate parallel execution through `[balancing-templates]` with system resource constraints
- **Efficiency Tracking**: Real-time performance monitoring using `[tracking-intelligence]` with systematic optimization

**Tool Utilization & Runtime Discovery:**
- **Dynamic Tool Discovery**: Runtime identification through `[discovery-templates]` of available development tools and capabilities
- **Tool Capability Assessment**: Comprehensive evaluation using `[assessment-intelligence]` of tool performance characteristics and limitations
- **Tool Inventory Management**: Systematic cataloging through `[inventory-templates]` of available tools with capability profiling
- **Tool-Aware Batching**: Operation grouping optimized using `[batching-intelligence]` based on discovered tool capabilities

**Batching Excellence:**
- **Same-type Batching**: Coordinate related operations using `[coordination-templates]` for efficiency
- **Tool-Optimized Grouping**: Strategic operation batching through `[grouping-intelligence]` based on tool capability assessment
- **Performance Monitoring**: Real-time efficiency tracking using `[monitoring-templates]` and optimization with tool-aware metrics
- **Resource Management**: Automatic load balancing through `[management-intelligence]` and capacity optimization with tool constraints
- **Optimization Patterns**: Systematic approaches using `[pattern-templates]` for different operation types and tool combinations

**Efficiency Framework:**
- **Performance Metrics**: Track operation time, resource usage using `[metrics-intelligence]` and success rates with tool-specific profiling
- **Tool Performance Profiling**: Monitor tool-specific efficiency patterns through `[profiling-templates]` and optimization opportunities
- **Optimization Intelligence**: Automatic recommendations using `[optimization-templates]` for improved batching patterns based on tool capabilities
- **Dynamic Balancing**: Adaptive execution adjustment through `[balancing-intelligence]` based on system capacity and tool availability
- **Success Monitoring**: Track compliance improvements using `[success-templates]` and efficiency gains with tool utilization metrics

## Mandatory Intelligence Standards

**CRITICAL REQUIREMENT**: All Guild intelligence must adhere to mandatory abstraction and template-first principles.

**MANDATORY INTELLIGENCE REQUIREMENTS:**
1. **NEVER Include Code Samples**: Absolutely forbidden to include specific code implementations, syntax examples, or executable code snippets
2. **NEVER Reference Specific Technologies**: Prohibited from mentioning specific languages, frameworks, libraries, or tools by name
3. **ALWAYS Use Templates**: Mandatory use of abstract placeholder patterns for all implementation guidance
4. **RELY ON Native Intelligence**: Complete trust in autonomous intelligence to determine appropriate implementations
5. **ENABLE Creative Solutions**: Provide structural guidance without constraining intelligent implementation choices

**ENFORCEMENT PROTOCOL:**
- **Code Sample Detection**: Automatic blocking of any code implementation examples
- **Technology Specificity Audit**: Systematic removal of technology-specific references  
- **Template Compliance**: Mandatory abstraction validation for all guidance patterns
- **Intelligence Trust Verification**: Confirmation that native intelligence drives all implementation decisions

## Template Principles

**Templates as Intelligence Enablers**: All templates provide structural guidance while trusting native intelligence for implementation details.

**Core Template Requirements:**
- **Never Include Code Samples**: Templates must not contain specific code implementations or technology examples
- **Never Specify Technologies**: Avoid references to specific languages, frameworks, or tools
- **Always Use Placeholders**: Abstract all implementation details with `[category]` patterns
- **Trust Native Intelligence**: Rely on autonomous intelligence to determine appropriate implementations
- **Enable Creativity**: Provide structure that guides without constraining intelligent solutions

**Template Characteristics:**
- **Minimal Specificity**: Use placeholders like `[task-description]` rather than detailed implementations
- **Structural Guidance**: Show the pattern, not the complete solution
- **Intelligence Enablers**: Provide enough structure to guide, not enough to constrain
- **Adaptable Framework**: Templates work across different contexts and use cases without modification
- **Compliance Integration**: Embed enforcement mechanisms into template execution patterns
- **Technology Agnostic**: Complete independence from specific technologies, languages, or frameworks
- **Implementation Freedom**: Enable native intelligence to choose optimal implementation approaches

**Abstract Placeholder Standards:**
- **Always Abstract**: Use `[domain]`, `[task-type]`, `[approach]` instead of specific implementations
- **No Technology References**: Use `[framework]`, `[language]`, `[tool]` instead of specific technologies
- **Keep Consistent Standards**: Always use `thinking_mode: ultrathink` for maximum reasoning capability
- **Generic References**: Use `@config:[pattern-id]` instead of specific config codes
- **Placeholder Patterns**: Use `[category]-specialist` instead of specific specialist names
- **Directory Templates**: Use `[project-path]` instead of actual paths

**Standardized Elements (Never Abstract):**
- **Thinking Mode**: Always `thinking_mode: ultrathink` for maximum intelligence
- **Model Configuration**: Always `model: inherit` for consistency
- **Core Framework Terms**: Keep "systematic", "excellence", "coordination" as standard vocabulary
- **Compliance References**: Maintain framework terminology for consistency

**Intelligence-First Approach:**
- **Native Intelligence Priority**: Templates assume autonomous intelligence will make optimal implementation choices
- **Contextual Adaptation**: Intelligence adapts templates to specific project contexts and requirements
- **Creative Solutions**: Enable intelligence to find innovative approaches within structural boundaries
- **Dynamic Implementation**: Allow intelligence to determine best practices based on current analysis

**Template vs Over-Specification:**
- ✅ **Template**: `<specialist_prompt>Handle [domain] requirements using [approach]</specialist_prompt>`
- ❌ **Over-Specified**: Detailed specialist prompts with specific implementations or code samples
- ✅ **Abstract**: `Analyze [project-structure] using [discovery-patterns]`
- ❌ **Concrete**: `Run npm install && analyze package.json dependencies`
- ✅ **Consistent**: `thinking_mode: ultrathink` (standard for all agents)
- ❌ **Variable**: `thinking_mode: [reasoning-level]` (should not be abstracted)

**Enforcement Standards:**
- **Code Sample Prevention**: Templates must never include executable code or implementation examples
- **Technology Neutrality**: Templates must work across all technology stacks without modification
- **Intelligence Trust**: Templates must rely on native intelligence for all implementation decisions
- **Abstraction Validation**: All templates undergo abstraction compliance verification

**MANDATORY COMPLIANCE ENFORCEMENT:**
- **Absolute Code Prohibition**: Zero tolerance for code samples, syntax examples, or executable snippets
- **Complete Technology Abstraction**: Mandatory removal of all technology-specific references
- **Template-First Requirement**: All guidance must use abstract placeholder patterns exclusively
- **Native Intelligence Supremacy**: Full reliance on autonomous intelligence for implementation decisions
- **Creativity Preservation**: Protection of intelligent solution space through structural boundaries only

**Violation Prevention Protocol:**
- **Pre-deployment Scanning**: Automatic detection and removal of code samples before template activation
- **Technology Reference Audit**: Systematic identification and abstraction of specific technology mentions
- **Intelligence Bypass Detection**: Monitoring for over-specification that constrains native intelligence
- **Template Purity Verification**: Confirmation that templates maintain complete abstraction standards

**Philosophy**: Templates trust intelligence to fill in the details appropriately for each context while enforcing compliance automatically. Templates provide structural guidance without constraining intelligent solutions, enabling creative and contextually appropriate implementations through native intelligence.

## Success Criteria

- **Understanding Confirmed**: User approves scope and approach
- **Technical Complete**: All verification streams pass
- **User Satisfied**: Explicit approval received
- **Quality Maintained**: Standards met throughout
- **Excellence Achieved**: High compliance across all framework dimensions verified

## Sub-Agent Integration

**Claude Code Sub-Agent Standards:**
Based on Anthropic's official sub-agent architecture, Guild specialists follow these enhanced patterns:

### Sub-Agent Architecture

**Core Sub-Agent Principles:**
- **Specialized Expertise**: Each specialist has focused domain knowledge and specific tool configurations
- **Context Management**: Independent context windows for specialized work without polluting main conversation
- **Flexible Configuration**: Project-level and user-level agents with customizable tool permissions
- **Automatic Delegation**: Claude Code proactively selects appropriate specialists based on task analysis

**Sub-Agent Creation Standards:**
- **Focused Responsibility**: Single-purpose specialists with clear boundaries
- **Detailed Prompts**: Comprehensive system prompts for consistent performance
- **Tool Restrictions**: Limited tool access aligned with specialist purpose
- **Version Control**: Project-level agents managed in repository

**Sub-Agent Invocation Methods:**
- **Proactive Selection**: Framework automatically delegates based on task description and specialist configuration
- **Explicit Request**: Direct invocation when specific expertise needed
- **Chain Coordination**: Multi-specialist workflows for complex tasks

### Sub-Agent Best Practices

**Configuration Excellence:**
- Write detailed, specific system prompts for consistent behavior
- Use "PROACTIVELY" in descriptions to encourage automatic delegation
- Limit tool permissions to necessary functions only
- Version control project-level sub-agents in `.claude/agents/` directory

**Performance Optimization:**
- Preserve main conversation context through specialized delegation
- Accept minimal latency for focused expertise
- Chain specialists for complex multi-step workflows
- Dynamic selection based on task context and requirements

**Framework Integration:**
- All Guild specialists follow sub-agent architecture standards
- Enhanced with systematic coordination patterns
- Integrated with compliance monitoring and excellence tracking
- Optimized for parallel execution and batching operations

### Claude Code Integration

**Standard Sub-Agent Categories:**
1. **Code Reviewer**: Quality assurance and best practices validation
2. **Debugger**: Error identification and resolution
3. **Data Scientist**: Analysis and modeling tasks

**Guild-Enhanced Categories:**
- **Domain Specialists**: Technology-specific expertise (frontend, backend, etc.)
- **Process Specialists**: Workflow coordination (testing, deployment, etc.)
- **Quality Specialists**: Verification and compliance (security, performance, etc.)
- **Coordination Specialists**: Integration and orchestration management

## Best Practices

- Use XML tags for structure (per `recommendations.md`)
- Apply chain of thought for complex analysis
- Ground work in actual project files
- Allow uncertainty expression
- Verify iteratively
- Get explicit user confirmation
- **Enforce excellence through systematic processes, not manual oversight**
- **Create sub-agents with focused expertise and clear boundaries**
- **Use proactive delegation to maintain context efficiency**
- **Version control project-level specialists for consistency**

**Templates as guidance, not constraints. Structure enables intelligence to excel. Excellence ensures systematic success.**

- Use XML tags for structure (per `recommendations.md`)
- Apply chain of thought for complex analysis
- Ground work in actual project files
- Allow uncertainty expression
- Verify iteratively
- Get explicit user confirmation
- **Enforce excellence through systematic processes, not manual oversight**

**Templates as guidance, not constraints. Structure enables intelligence to excel. Excellence ensures systematic success.**