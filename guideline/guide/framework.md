# Guild System Framework

## Core Philosophy

**Structure enables intelligence. Intelligence optimizes structure.**

The Guild system balances systematic methods with adaptive intelligence:

- **Systematic Foundation**: Provides reliability and comprehensive coverage
- **Intelligent Optimization**: Enables excellence and creative solutions  
- **Unified Integration**: Combines both for superior outcomes
- **Continuous Evolution**: Improves systems based on insights

## Decision Authority

**Clear boundaries resolve conflicts:**

- **Structure Governs**: Safety standards, quality gates, coverage requirements
- **Intelligence Governs**: Implementation approaches, problem-solving, optimization
- **User Decides**: Scope, priorities, trade-offs, satisfaction

## Core Principles

**Adaptive Intelligence**: Trust native intelligence within coordination boundaries. Use systematic understanding for multi-agent coordination.

**Parallel-First Execution**: Default to simultaneous execution. Sequential only when dependencies require it.

**Task Decomposition**: Break complex work into parallelizable components. Challenge serial assumptions.

**Strategic Specialist Creation**: Create specialists when parallel benefits exceed coordination costs. Batch launches for efficiency.

**Agent Selection Priority**: Prefer existing available agents over dynamic creation. Use dynamic specialist creation only as a fallback when no suitable existing agents can handle the task.

**Quality Standards**: Follow all Anthropic best practices from `recommendations.md`. Maintain project conventions and error handling.

**Template Standards**: Create examples as simple templates without excessive detail. Provide structure that enables intelligence, not constraints that limit creativity.

**Modernization Research**: Research current versions and best practices to avoid outdated libraries, APIs, and tool usage. Verify compatibility and security of dependencies.

**Impact Analysis**: Research all project locations where changes may be needed to ensure complete implementation without gaps. Map dependencies and affected areas.

## Execution Flow

### Understanding Phase
- Apply systematic analysis to clarify requirements
- Research current versions, best practices, and security considerations
- Identify all project areas affected by proposed changes
- Identify scope and coordination needs
- Confirm approach with user

### Decomposition Phase  
- Break tasks into atomic, parallelizable units
- Map all affected project areas to prevent implementation gaps
- Identify true dependencies vs assumed dependencies
- Plan coordination interfaces where needed
- Design specialist architecture for maximum efficiency

### Execution Phase
- Launch specialists in parallel when beneficial
- Provide comprehensive descriptions (3-4 sentences minimum)
- Include error handling and gap detection
- Monitor coordination points

### Verification Phase
- **Functional**: Requirements met, workflows working
- **Integration**: Components communicate properly
- **Quality**: Follows patterns, maintainable, proper error handling
- **User Satisfaction**: Final authority for completion

### Iteration Phase
- Continue until all verification passes and user satisfied
- Fix gaps immediately and re-verify
- Never consider work complete without user confirmation

## Template Principles

**Examples as Templates**: All examples should be simple templates that provide structure without excessive implementation details.

**Template Characteristics:**
- **Minimal Specificity**: Use placeholders like `[task-description]` rather than detailed implementations
- **Structural Guidance**: Show the pattern, not the complete solution
- **Intelligence Enablers**: Provide enough structure to guide, not enough to constrain
- **Adaptable Framework**: Templates should work across different contexts and use cases

**Template vs Over-Specification:**
- ✅ **Template**: `<specialist_prompt>Handle [domain] requirements using [approach]</specialist_prompt>`
- ❌ **Over-Specified**: Detailed 50-line specialist prompts with specific implementations

**Philosophy**: Templates trust intelligence to fill in the details appropriately for each context.

## Success Criteria

- **Understanding Confirmed**: User approves scope and approach
- **Technical Complete**: All verification streams pass
- **User Satisfied**: Explicit approval received
- **Quality Maintained**: Standards met throughout

## Best Practices

- Use XML tags for structure (per `recommendations.md`)
- Apply chain of thought for complex analysis
- Ground work in actual project files
- Allow uncertainty expression
- Verify iteratively
- Get explicit user confirmation

**Templates as guidance, not constraints. Structure enables intelligence to excel.**